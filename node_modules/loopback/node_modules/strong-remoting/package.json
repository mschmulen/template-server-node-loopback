{
  "name": "strong-remoting",
  "description": "StrongLoop Remoting Module",
  "keywords": [
    "StrongLoop",
    "LoopBack",
    "Remoting",
    "REST"
  ],
  "version": "1.0.0-1",
  "scripts": {
    "test": "mocha"
  },
  "dependencies": {
    "debug": "~0.7.2",
    "express": "~3.4.0",
    "eventemitter2": "~0.4.13",
    "qs": "~0.6.5",
    "cors": "~1.0.1"
  },
  "devDependencies": {
    "mocha": "~1.12.1",
    "supertest": "~0.7.1",
    "socket.io": "~0.9.6",
    "socket.io-client": "~0.9.6"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/strongloop/strong-remoting"
  },
  "license": "MIT",
  "supported": true,
  "readme": "# strong-remoting\n\n_Communicating between objects, even across processes, should be easy._\n\nIt's a common requirement: Objects (and, therefore, data) in your Node\napplication need to be reachable from other Node processes, browsers, and even\nmobile clients. _If it's such a common requirement, shouldn't it be easy?_\n\nStop worrying about the transport layer while you're developing your\napplication, and just build.\n\n## Features\n\n - Make local functions remotable, exported over our Adapters\n - Support for multiple transports, including custom transports\n - Manage (de)serialization to/from JSON\n - Multiple client SDKs, including mobile clients\n\n#### Server Support\n\n**Node.js** is the only planned server environment. This may change in the\nfuture if there is demand for other implementations.\n\n#### Client SDK Support\n\nFor higher-level transports, such as REST and Socket.IO, existing clients will\nwork well. If you want to be able to swap out your transport, use one of our\nsupported clients. The same Adapter model available on the server applies to\nclients, so you can switch transports on both the server and all clients without\nchanging your application-specific code.\n\n - **iOS** - [Documentation](http://docs.strongloop.com/strong-remoting-clients#ios)\n - **Node.js** - Coming Soon!\n - **HTML5** - Coming Soon!\n - **Java** - Coming Soon!\n\n## Install\n\n```sh\n$ npm install strong-remoting\n```\n\n## Quick Start\n\nFirst, let's up a basic `strong-remoting` server with a single remote method,\n`user.greet`.\n\n```js\n// Create a collection of remote objects.\nvar remotes = require('strong-remoting').create();\n\n// Export a `user` object.\nvar user = remotes.exports.user = {\n  greet: function (str, callback) {\n    callback(null, str + ' world');\n  }\n};\n\n// Share the `greet` method.\nuser.greet.shared = true;\nuser.greet.accepts = { arg: 'str' };\nuser.greet.returns = { arg: 'msg' };\n\n// Expose it over the REST transport.\nrequire('http')\n  .createServer(remotes.handler('rest'))\n  .listen(3000);\n```\n\nThen, we can invoke `user.greet()` easily with `curl` (or any HTTP client)!\n\n```sh\n$ curl http://localhost:3000/user/greet?str=hello\n{\n  \"msg\": \"hello world\"\n}\n```\n\n## Concepts\n\n### Remote Objects\n\nMost Node applications expose a remotely-available API. strong-remoting allows\nyou to build your app in vanilla JavaScript and export Remote Objects over the\nnetwork the same way you export functions from a module. Since they're just\nplain JavaScript Objects, you can always invoke methods on your Remote Objects\nlocally in JavaScript, whether from tests or other, local Objects.\n\n### Remote Object Collections\n\nThe result of `require('strong-remoting').create()`, Collections are responsible\nfor binding their Remote Objects to transports, allowing you to swap out the\nunderlying transport without changing any of your application-specific code.\n\n### Adapters\n\nAdapters provide the transport-specific mechanisms to make Remote Objects (and\nCollections thereof) available over their transport. The REST Adapter, for\nexample, handles an HTTP server and facilitates mapping your objects to RESTful\nresources. Other Adapters, on the other hand, might provide a less opionated,\nRPC-style network interface. Your application code doesn't need to know what\nAdapter it's using.\n\n### Hooks\n\nHooks allow you to run code before Remote Objects are constructed or methods on\nthose Objects are invoked. For example, you can prevent actions based on context\n(HTTP request, User credentials, etc).\n\n```js\n// Do something before our `user.greet` example, earlier.\nremotes.before('user.greet', function (ctx, next) {\n  if((ctx.req.param('password') || '').toString() !== '1234') {\n    next(new Error('Bad password!'));\n  } else {\n    next();\n  }\n});\n\n// Do something before any `user` method.\nremotes.before('user.*', function (ctx, next) {\n  console.log('Calling a user method.');\n  next();\n});\n\n// Do something before a `dog` instance method.\nremotes.before('dog.prototype.*', function (ctx, next) {\n  var dog = this;\n  console.log('Calling a method on \"%s\".', dog.name);\n  next();\n});\n\n// Do something after the `speak` instance method.\n// NOTE: you cannot cancel a method after it has been called.\nremotes.after('dog.prototype.speak', function (ctx, next) {\n  console.log('After speak!');\n  next();\n});\n\n// Do something before all methods.\nremotes.before('**', function (ctx, next, method) {\n  console.log('Calling:', method.name);\n  next();\n});\n\n// Modify all returned values named `result`.\nremotes.after('**', function (ctx, next) {\n  ctx.result += '!!!';\n  next();\n});\n```\n\nSee the [before-after example](https://github.com/strongloop/strong-remoting/blob/master/example/before-after.js)\nfor more info.\n\n### Streams\n\nstrong-remoting supports methods that expect or return `Readable` and\n`Writeable` streams. This allows you to stream raw binary data such as files\nover the network without writing transport-specific behaviour.\n\n#### Example\n\nJust like our Quick Start, we start off by exposing a method of the `fs` Remote\nObject, `fs.createReadStream`, over the REST Adapter.\n\n```js\n// Create a Collection.\nvar remotes = require('strong-remoting').create();\n\n// Share some fs module code.\nvar fs = remotes.exports.fs = require('fs');\n\n// Specifically export the `createReadStream` function.\nfs.createReadStream.shared = true;\n\n// Describe the arguments.\nfs.createReadStream.accepts = {arg: 'path', type: 'string'};\n\n// Describe the stream destination.\nfs.createReadStream.http = {\n  // Pipe the returned `Readable` stream to the response's `Writable` stream.\n  pipe: {\n    dest: 'res'\n  }\n};\n\n// Expose the Collection over the REST Adapter.\nrequire('http')\n  .createServer(remotes.handler('rest'))\n  .listen(3000);\n```\n\nThen we invoke `fs.createReadStream()` using `curl`.\n\n```sh\n$ curl http://localhost:3000/fs/createReadStream?path=some-file.txt\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/strongloop/strong-remoting/issues"
  },
  "_id": "strong-remoting@1.0.0-1",
  "_from": "strong-remoting@~1.0.0"
}
